# Long Branch (LBR)
INCLUDE ../inc/unary.nsa
INCLUDE ../inc/zpage.nsa
INCLUDE ../inc/pages.nsa
PAGE LBR_PG

# $PREG - zero page location of the P register
# $PREG:  10> 100
# $REG0H: 100> 222 Big-endian
# $REG0L: 101> 254
# assume: Y = $VMS
LDZ HL, $INC2$NULL
FNH DZ, HLD        # double inc state
LD HL, $INC$FORK
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = lower byte address (y=101)
FNFH DZ, XD        # inc value of lower byte put in X ([101]->254->255->X)
FNEL A, PC         # fork based on X
#16

ADDR 0x40          # if X=0xFF : iden Y, inc X, inc Y
LD HL, $IDEN$NULL
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = upper byte address (y=100)
FNH DZ, Y          # get value of upper byte put in ([100]->222->Y)
FNFH B, NA         # get value of memory put in A (A=[Y,X]=[222,255])
LDZ Y, $TEMP
FNFH AZ, ND        # store A in temp
#32
LD HL, $INC$IDEN
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = lower byte address (y=101)
FNFH DZ, XD        # inc value of lower byte put in X ([101]->255->0->X)
LD Y, $PREG        # zero page address of PC (Y=10, [10]->100)
FNFL DZ, Y         # Y = upper byte address (y=100)
FNFH DZ, ND        # inc value of upper byte leave in A ([100]->222->223->Y)
LD HL, $IDEN$INC
FNH A, Y           # move A to Y
FNFH B, NA         # get value of memory put in A (A=[Y,X]=[223,0])
#56
LD Y, $PREG        # zero page address of PC (Y=10, [10]->100)
FNFL DZ, Y         # Y = lower byte address (y=101)
FNFH AZ, ND        # save A to lower byte of P (A->[101])
LDZ Y, $TEMP
FNFH DZ, NA        # copy temp to A
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = upper byte address (y=100)
FNH AZ, HLD        # save A to upper byte of P (A->[100])
#75
NOP
NOP
NOP
LD HL, $NOP_INST
LD Y, $VMS         # set Y = $VMS on exit
VMPHL DZ, PGA      # jump to next VMC
#86

ADDR 0x80          # if X=0 : inc Y, inc X, iden Y
LD HL, $INC$IDEN
LD Y, $PREG        # zero page address of PC (Y=10, [10]->100)
FNFL DZ, Y         # Y = upper byte address (y=100)
FNH DZ, HLD        # inc value of upper byte leave in A ([100]->222->223->Y)
LD HL, $IDEN$INC
FNH A, Y           # move A to Y
FNFH B, NA         # get value of memory put in A (A=[Y,X]=[223,0])
LDZ Y, $TEMP
FNH AZ, HLD        # store A in temp
#36
LD HL, $INC$IDEN
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = lower byte address (y=101)
FNFH DZ, XD        # inc value of lower byte put in X ([101]->255->0->X)
LD HL, $IDEN$INC
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = upper byte address (y=100)
FNH DZ, Y          # get value of upper byte leave in A ([100]->223->Y)
FNFH B, NA         # get value of memory put in A (A=[Y,X]=[223,0])
#56
LD Y, $PREG        # zero page address of PC (Y=10, [10]->100)
FNFL DZ, Y         # Y = lower byte address (y=101)
FNFH AZ, ND        # save A to lower byte of P (A->[101])
LDZ Y, $TEMP
FNFH DZ, NA        # copy temp to A
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = upper byte address (y=100)
FNH AZ, HLD        # save A to upper byte of P (A->[100])
#75
NOP
NOP
NOP
LD HL, $NOP_INST
LD Y, $VMS         # set Y = $VMS on exit
VMPHL DZ, PGA      # jump to next VMC
#86

ADDR 0xC0          # if else : iden Y, inc X, iden Y
LD HL, $IDEN$NULL
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = upper byte address (y=100)
FNH DZ, Y          # get value of upper byte put in ([100]->222->Y)
FNFH B, NA         # get value of memory put in A (A=[Y,X]=[222,255])
LDZ Y, $TEMP
FNFH AZ, ND        # store A in temp
#32
LD HL, $INC$IDEN
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = lower byte address (y=101)
FNFH DZ, XD        # inc value of lower byte put in X ([101]->255->0->X)
LD HL, $IDEN$INC
LD Y, $PREG        # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = upper byte address (y=100)
FNH DZ, Y          # get value of upper byte leave in A ([100]->222->Y)
FNFH B, NA         # get value of memory put in A (A=[Y,X]=[223,0])
#52
LD Y, $PREG        # zero page address of PC (Y=10, [10]->100)
FNFL DZ, Y         # Y = lower byte address (y=101)
FNFH AZ, ND        # save A to lower byte of P (A->[101])
LDZ Y, $TEMP
FNFH DZ, NA        # copy temp to A
LDZ Y, $PREG       # zero page address of PC (Y=10, [10]->100)
FNH DZ, Y          # Y = upper byte address (y=100)
FNH AZ, HLD        # save A to upper byte of P (A->[100])
#71
NOP
NOP
NOP
NOP
NOP
NOP
NOP
LD HL, $NOP_INST
LD Y, $VMS         # set Y = $VMS on exit
VMPHL DZ, PGA      # jump to next VMC
#86
