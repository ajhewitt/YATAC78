# fetch
INCLUDE ../inc/unary.nsa
INCLUDE ../inc/zpage.nsa
INCLUDE ../inc/pages.nsa
PAGE FETCH_PG

# $PREG - zero page location of the P register
# (SEP instruction updates value of $PREG)
# $PREG:  10> 100
# $REG0H: 100> 222 Big-endian
# $REG0L: 101> 111
# assume: Y = $VMS
LD HL, $INC$FORK
FNFH DZ, ND        # inc state
LDZ Y, $PREG       # zero page address of P (Y=10, [10]->100)
FNH DZ, Y          # load PC; Y = ‘lower’ byte address (y=101)
FNFH DZ, XD        # inc value of lower byte put in X  [101]->111->112
LDZ Y, $PREG
FNEL A, PC
#17

ADDR 0x40
LD HL, $IDEN$NULL  # load inc fn if zero after inc
FNH DZ, Y          # load P; Y = ‘upper’ byte address y=100
FNH DZ, Y
FNFH B, HLA        # HL=[Y,X]=[222,112]
NOP
NOP
NOP
NOP
#30
NOP
LD Y, $INST
MVHLZ ND           # cache instruction (from HL)
LDZ Y, $VMS        # set Y = $VMS on exit
VMPHL DZ, PGA      # jump to next VMC

ADDR 0x80
LD HL, $INC$IDEN   # load inc fn if zero after inc
FNFL DZ, Y         # zero page address of P (Y=10, [10]->100)
FNFH DZ, ND        # load P; Y = ‘upper’ byte address y=100
FNFL A, Y
FNFL B, HL         # HL=[Y,X]=[222,112]
#31
LD Y, $INST
MVHLZ ND           # cache instruction (from HL)
LDZ Y, $VMS        # set Y = $VMS on exit
VMPHL DZ, PGA      # jump to next VMC

ADDR 0xC0
LD HL, $IDEN$NULL  # load inc fn if zero after inc
FNH DZ, Y          # load P; Y = ‘upper’ byte address y=100
FNH DZ, Y
FNFH B, HLA        # HL=[Y,X]=[222,112]
NOP
NOP
NOP
NOP
#30
NOP
LD Y, $INST
MVHLZ ND           # cache instruction (from HL)
LDZ Y, $VMS        # set Y = $VMS on exit
VMPHL DZ, PGA      # jump to next VMC
