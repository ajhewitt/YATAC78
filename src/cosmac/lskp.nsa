# Long skip (LSKP)
INCLUDE ../inc/unary.nsa
INCLUDE ../inc/zpage.nsa
INCLUDE ../inc/pages.nsa
PAGE LSKP_PG

# $PREG - zero page location of the P register
# (SEP instruction updates value of $PREG)
# $PREG:  10> 100
# $REG0H: 100> 222 Big-endian
# $REG0L: 101> 111
# assume: Y = $VMS
LD HL, $INC$FORK
FNFH DZ, ND        # inc state
LDZ Y, $PREG       # zero page address of P (Y=10, [10]->100)
FNH DZ, Y          # Y = lower byte address (y=101)
FNFH DZ, ND        # inc value of lower byte ([101]->111->112)
FNEL A, PC
#15

ADDR 0x40
FNH DZ, HLD        # inc value of lower byte ([101]->112->113)
LD HL, $INC$IDEN
LD Y, $PREG        # zero page address of P (Y=10, [10]->100)
#21
FNFL DZ, Y         # Y = upper byte address y=100
FNH DZ, HLD        # inc value of upper byte ([100]->222->223)
NOP
NOP
NOP
NOP
#30
NOP
NOP
NOP
NOP
NOP
LD HL, $NOP_INST
LD Y, $VMS         # set Y = $VMS on exit
VMPHL DZ, PGA      # jump to next VMC
#43

ADDR 0x80
FNH DZ, HLD        # inc value of lower byte ([101]->112->113)
LD HL, $INC$IDEN
LD Y, $PREG        # zero page address of P (Y=10, [10]->100)
#21
FNFL DZ, Y         # Y = upper byte address y=100
FNH DZ, HLD        # inc value of upper byte ([100]->222->223)
NOP
NOP
NOP
NOP
#30
NOP
NOP
NOP
NOP
NOP
LD HL, $NOP_INST
LD Y, $VMS         # set Y = $VMS on exit
VMPHL DZ, PGA      # jump to next VMC
#43

ADDR 0xC0
FNH DZ, HLD        # inc value of lower byte ([101]->112->113)
NOP
NOP
NOP
#20
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
#30
NOP
NOP
NOP
NOP
NOP
LD HL, $NOP_INST
LD Y, $VMS         # set Y = $VMS on exit
VMPHL DZ, PGA      # jump to next VMC
#43
