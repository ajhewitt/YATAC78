# H-sync with comms rx on execute
INCLUDE ../inc/unary.nsa
INCLUDE ../inc/zpage.nsa
INCLUDE ../inc/pages.nsa
PAGE RSYNCE_PG

$SERM 0
$SERS 0

# PMODE: column in AV used during process cycle
# VLINE: line(page) in video ram
# VMS: [mode_line][e][cycle count]
#           0,1,2  0  0,1,2,3,4,5
#         3,4,5,6  1  0,1,2,3,4
#        7,8,9,10     0,1,2,3,4
#  11,12,13,14,15     0,1,2,3
# assume Y = $VMS
LDZ HL, $INCLINE$NULL
FNH DZ, HLD           # H=mode_line+1, L=E000
LD Y, $PMODE
VIDH DZ, SA           # mode_line, pmode —> S
#9/7
LDP HL, $IDEN$IDEN    # sign bit low, don’t inc vline
LDN HL, $INC$IDEN     # sign bit high, inc vline
LD Y, $VLINE
FNFH DZ, VD           # increment? vline —> V
FNFL E, HL            # serial inputs -> H
#20/17
LD Y, $COMLS
COMH DZ, ND           # update comms line state
LD HL, $IDEN$FORKJ
LD Y, $RMODE
FNEL DZ, PC           # comms  mode fork
#32/27

ADDR 0x20             # mode 0: receive off
NOP
LDZ Y, $INST
FNH DZ, HL            # inst cache -> HL
LD Y, $VMS            # set Y = $VMS on exit
VMPHL DZ, PGA         # jump to next VMC
#43/39

ADDR 0x30             #32 - mode 0x01: receive enable
LD HL, $0x40
LD Y, $SERM
MVHL AZ, ND           # 4 -> serial multiplier
#40
LD HL, $0xFF
LDZ Y, $SERS
MVHL AZ, ND           # 0xFF -> serial state
LD HL, $INC$NULL
#50
LDZ Y, $RMODE
FNH DZ, HLD           # 2 -> rx mode
LD HL, $0xEF
LD Y, $EREG
ANDHL DZ, ED          # 0 -> RTS (assert)
LD PC, $EXIT64
#64

ADDR 0x50             #32 - mode 0x02: receive start, adjust sample
LDZ Y, $COMPS
FNH DZ, HLA           # A sign = Rx start bit
LDN PC, $EXIT38       # exit on stop bit
LD Y, $SERS           # serial state: [n-1,n-2]
#39
MVH DZ, NA            # A = [n-1,n]
LD HL, $SWAP$NULL
FNH AZ, HLD           # [n,n-1] -> serial state
LD HL, $RXS2M$NULL
LD Y, $SERM
#50
FNEH AZ, ND           # serial state -> [multiplier,mode] -> serial multiplier
LD HL, $SWAP$NULL
FNH A, HL             # H = mode
LD Y, $RMODE
#59
MVH DZ, ND            # H -> rx mode
LD PC, $EXIT64
#64

ADDR 0x80             #32 mode 0x04-0x12: receive data bit
LD HL, $RXBUFF
MVHL A, XA            # X = Rx buffer
LD HL, $IDEN$NULL
#40/134
LDZ Y, $SERM
FNH DZ, HL            # H = serial multiplier
LD Y, $COMPS
MULH DZ, NA           # A sign = Rx data bit
#49/141
LDP HL, $LSR$IDEN     # shift right, reset MSB
LDN HL, $NSR$IDEN     # shift right, set MSB
LD Y, $RXWRIDX
FNFL DZ, Y            # Y = Rx write index
FNFH D, ND            # Rx data shift right, set/reset MSB
#60/151
LD HL, $INC2$NULL
LDZ Y, $RMODE
FNH DZ, HLD           # mode+2
LD PC, $EXIT68
#68/158

ADDR 0xA0             #32 - mode 0x14: receive stop
LD HL, $0xEE          # HL = -0x12
LD Y, $RMODE
ADDHL DZ, ND          # 2 -> Rx mode
#40/166
LD HL, $INC$2COM
LD Y, $VMS
FNFH DZ, ND           # VMS+1
LD Y, $RXWRIDX
#49/174
FNFH DZ, ND           # A,RxWrIndex+1
LD Y, $RXRDIDX
FNFL DZ, HL           # HL = -RxRdIndex
ADDHL A, NA           # A = RxWrIndex - RxRdIndex
#61/182
LD HL, $UNDER?$NULL
FNH A, HLA            # A = -1 if RxWrIndex == RxRdIndex-1
LDP PC, $EXIT67       # jump on end of transmission
LD HL, $0x10
LD Y, $EREG
#70/191
ORHL DZ, ED           # 1 -> RTS (deassert)
$EXIT74
LD HL, $IDEN$NULL
LDZ Y, $INST
FNH DZ, HL            # inst cache -> HL
#80/198
LD Y, $VMS            # set Y = $VMS on exit
VMPHL DZ, PGA         # jump to next VMC
#86/202

$EXIT67
NOP
NOP
NOP
#70/205
NOP
NOP
LD PC, $EXIT74
#74/209

$EXIT38
NOP
NOP
#40/211
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
#50/221
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
#60/231
NOP
NOP
NOP
NOP
$EXIT64
NOP
NOP
NOP
NOP
$EXIT68
LD HL, $INC$NULL
#70/241
LDZ Y, $VMS
FNH DZ, HLD           # VMC+1
LD HL, $IDEN$NULL
LDZ Y, $INST
FNH DZ, HL            # inst cache -> HL
#80/249
LD Y, $VMS            # set Y = $VMS on exit
VMPHL DZ, PGA         # jump to next VMC
#86/253
