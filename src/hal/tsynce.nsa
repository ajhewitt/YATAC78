# H-sync with comms tx on execute
INCLUDE ../inc/unary.nsa
INCLUDE ../inc/zpage.nsa
INCLUDE ../inc/pages.nsa
PAGE TSYNCE_PG

# PMODE: column in AV used during process cycle
# VLINE: line(page) in video ram
# VMS: [mode_line][e][cycle count]
#           0,1,2  0  0,1,2,3,4,5
#         3,4,5,6  1  0,1,2,3,4
#        7,8,9,10     0,1,2,3,4
#  11,12,13,14,15     0,1,2,3
# assume Y = $VMS
LDZ HL, $INCLINE$NULL
FNH DZ, HLD           # H=mode_line+1, L=E000
LD Y, $PMODE
VIDH DZ, SA           # mode_line, pmode —> S
#9/7
LDP HL, $IDEN$IDEN    # sign bit low, don’t inc vline
LDN HL, $INC$IDEN     # sign bit high, inc vline
LD Y, $VLINE
FNFH DZ, VD           # increment? vline —> V
FNFL E, HL            # serial inputs -> H
#20/17
LD Y, $COMLS
COMH DZ, ND           # update comms line state
LD HL, $IDEN$FORKF
LD Y, $TMODE
FNEL DZ, PC           # comms  mode fork
#32/27

ADDR 0x20             #32 - mode 0: no comms
NOP
LDZ Y, $INST
FNH DZ, HL            # inst cache -> HL
LD Y, $VMS            # set Y = $VMS on exit
VMPHL DZ, PGA         # jump to next VMC
#43/39

ADDR 0x28             #32 - mode 0x19,0x1B: keyboard jump page
LD PG, $KSCANE_PG
#34/42

ADDR 0x30             #32 - mode 0x02: transmit start
LD HL, $0x40
MULH E, NA            # A sign = CTS
LDN PC, $NOT_CTS      # jump on not clear to send
LD HL, $INC2$NULL
#40/56
FNH DZ, HLD           # 4 -> Tx mode
LD HL, $0x70
LD Y, $EREG
ANDH DZ, ED           # 0 -> Tx (start bit)
LD PC, $EXIT51
#51/65

$NOT_CTS              #39
LD HL, $0xFE
ADDHL DZ, ND          # Tx mode-2
NOP
NOP
NOP
NOP
NOP
#50/74
$EXIT50
NOP
$EXIT51
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
#60/83
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
$EXIT68
LD HL, $INC$NULL
#70/92
LD Y, $VMS
FNH DZ, HLD           # VMC+1
LD HL, $IDEN$NULL
LDZ Y, $INST
FNH DZ, HL            # inst cache -> HL
#80/100
LD Y, $VMS            # set Y = $VMS on exit
VMPHL DZ, PGA         # jump to next VMC
#86/104

ADDR 0x70             #32 - mode 0x04-0x13: transmit data bit
LD HL, $TXBUFF
MVHL A, XA            # X = Tx buffer
LD HL, $INC2$NULL
#40/118
LDZ Y, $TMODE
FNH DZ, HLD           # mode+2
LD HL, $REVERSE$IDEN
LDZ Y, $TXRDIDX
FNFL DZ, Y            # Y = Tx read index
#51/127
FNFH D, NA            # A sign = Tx LSB
LD HL, $LSR$NULL
LDP PC, $TX_HIGH      # jump to set Tx
#TX_LOW
FNH D, HLD            # Tx byte >> 1
LD HL, $0x70
#61/136
LD Y, $EREG
ANDH DZ, ED           # Tx reset
LD PC, $EXIT68
$TX_HIGH
FNH D, HLD            # Tx byte >> 1
#60/143
LD HL, $0x80
LD Y, $EREG
ORH DZ, ED            # Tx set
NOP
LD HL, $INC$NULL
#70/152
LD Y, $VMS
FNH DZ, HLD           # VMC+1
LD HL, $IDEN$NULL
LDZ Y, $INST
FNH DZ, HL            # inst cache -> HL
#80/160
LD Y, $VMS            # set Y = $VMS on exit
VMPHL DZ, PGA         # jump to next VMC
#86/164

ADDR 0xB0             #32 - mode 0x14,0x15: transmit stop
LD HL, $INC$2COM
LD Y, $VMS
FNFH DZ, ND           # VMS+1
LD Y, $TXRDIDX
#41/184
FNFH DZ, ND           # A,TxRdIndex+1
LD Y, $TXWRIDX
FNFL DZ, HL           # HL = -TxWrIndex
#49/190
ADDHL A, NA           # A = TxRdIndex - TxWrIndex
LDZ HL, $ZERO?$NULL
FNH A, HLA            # A = 0 if TxRdIndex == TxWrIndex
LDP HL, $0xEC         # -0x14
LDN HL, $0xEE         # -0x12
#60/199
LD Y, $TMODE
ADDHL DZ, ND          # 0,2 -> Tx mode
LD HL, $0x80
LD Y, $EREG
#70/207
ORH DZ, ED            # 1 -> Tx (stop bit)
NOP
LD HL, $IDEN$NULL
LDZ Y, $INST
FNH DZ, HL            # inst cache -> HL
#80/215
LD Y, $VMS            # set Y = $VMS on exit
VMPHL DZ, PGA         # jump to next VMC
#86/219

ADDR 0xE0             #32 - mode 0x01,0x03: keyboard start
LD HL, $0x18
LD Y, $TMODE
ADDHL DZ, ND          # mode+0x18 (0x19,0x1B)
#40/230
LD HL, $0x20
LD Y, $EREG
ANDHL DZ, ED          # kbd clock enable
LD PC, $EXIT50
#50/238

ADDR 0xF0             #32 - mode 0x18,0x1A: keyboard stop
LD HL, $0xE8
LD Y, $TMODE
ADDHL DZ, ND          # mode-0x18 (0,2)
#40/246
LD HL, $0xDF
LD Y, $EREG
ORHL DZ, ED           # kbd clock disable
LD PC, $EXIT50
#50/254
