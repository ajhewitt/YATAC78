# H-sync with comms tx on execute
INCLUDE ../inc/unary.nsa
INCLUDE ../inc/zpage.nsa
INCLUDE ../inc/pages.nsa
PAGE TSYNCE_PG

# PMODE: column in AV used during process cycle
# VLINE: line(page) in video ram
# VMS: [mode_line][e][cycle count]
#           0,1,2  0  0,1,2,3,4,5
#         3,4,5,6  1  0,1,2,3,4
#        7,8,9,10     0,1,2,3,4
#  11,12,13,14,15     0,1,2,3
# assume Y = $VMS
LDZ HL, $INCLINE$NULL
FNH DZ, HLD           # H=mode_line+1, L=E000
LD Y, $PMODE
VIDH DZ, SA           # mode_line, pmode —> S
#9/7
LDP HL, $IDEN$IDEN    # sign bit low, don’t inc vline
LDN HL, $INC$IDEN     # sign bit high, inc vline
LD Y, $VLINE
FNFH DZ, VD           # increment? vline —> V
FNFL E, HL            # serial inputs -> H
#20/17
LD Y, $COMLS
COMH DZ, ND           # update comms line state
LD HL, $IDEN$FORKT
LD Y, $TMODE
FNEL DZ, PC           # comms  mode fork
#32/27

ADDR 0x20             #32 - mode 0: no comms
NOP
LDZ Y, $INST
FNH DZ, HL            # inst cache -> HL
LD Y, $VMS            # set Y = $VMS on exit
VMPHL DZ, PGA         # jump to next VMC
#43/39

ADDR 0x30             #32 - mode 2: transmit start
LD HL, $4$2COM
MULH E, NA            # A sign = CTS
LDN PC, $STOP1        # jump on not clear to send
LDZ Y, $TXRDIDX
#40/56
FNFL DZ, HL           # HL = -TxRdIndex
LD Y, $TXWRIDX
ADDHL DZ, NA          # A = TxWrIndex - TxRdIndex
LD HL, $ZERO?$NULL
#41/64
FNH A, HLA            # A = 0 if TxWrIndex == TxRdIndex
LDP PC, $STOP2        # jump on end of transmission
LD HL, $0x70
LD Y, $EREG
ANDH DZ, ED           # 0 -> Tx (start bit)
#60/73
LD HL, $INC2$NULL
LDZ Y, $TMODE
FNH DZ, HLD           # 4 -> Tx mode
LD PC, $EXIT
#68/80

$STOP1                #39 - not clear to send
NOP
#40/81
NOP
NOP
$STOP3
NOP
NOP
NOP
$STOP2                #45 - no data to tx
NOP
NOP
NOP
NOP
NOP
$STOP4
#50/91
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
#59/100
LD HL, $0x80
LD Y, $EREG
ORH DZ, ED            # 1 -> Tx (stop bit)
LD PC, $EXIT
#68/108

ADDR 0x70             #32 - mode 4-0x17: transmit bit
LD HL, $TXBUFF
MVHL A, XA            # X = Tx buffer
LD HL, $INC2$NULL
#40/118
LDZ Y, $TMODE
FNH DZ, HLD           # mode+2
LD HL, $REVERSE$IDEN
LDZ Y, $TXRDIDX
FNFL DZ, Y            # Y = Tx read index
#51/127
FNFH D, NA            # A sign = Tx LSB
LD HL, $LSR$NULL
LDP PC, $TXHIGH       # jump to set Tx
#TXLOW
FNH D, HLD            # Tx byte >> 1
LD HL, $0x70
#61/136
LD Y, $EREG
ANDH DZ, ED           # Tx reset
LD PC, $EXIT
$TXHIGH
FNH D, HLD            # Tx byte >> 1
#60/143
LD HL, $0x80
LD Y, $EREG
ORH DZ, ED            # Tx set
NOP
$EXIT
LD HL, $INC$NULL
#70/152
LD Y, $VMS
FNH DZ, HLD           # VMC+1
LD HL, $IDEN$NULL
LDZ Y, $INST
FNH DZ, HL            # inst cache -> HL
#80/160
LD Y, $VMS            # set Y = $VMS on exit
VMPHL DZ, PGA         # jump to next VMC
#86/164

ADDR 0xB0             #32 - mode 0x18,0x19: transmit stop
LD HL, $0xEA          # HL = -0x16
LD Y, $TMODE
ADDHL DZ, ND          # 2 -> Tx mode
#40/166
LD PC, $STOP3
#42/168

ADDR 0xC0             #32 - mode 1,3: keyboard start
LD HL, $0x1C
LD Y, $TMODE
ADDHL DZ, ND          # mode+0x1C (0x1D,0x1F)
#40
LD HL, $0x20
LD Y, $EREG
ANDHL DZ, ED          # ps/2 clock enable
LD PC, $STOP4
#50

ADDR 0xD0             #32 - mode 0x1C,0x1E: keyboard stop
LD HL, $0xE4
LD Y, $TMODE
ADDHL DZ, ND          # mode-0x1C (0,2)
#40
LD HL, $0xDF
LD Y, $EREG
ORHL DZ, ED           # ps/2 clock disable
LD PC, $STOP4
#50

ADDR 0xE0             #32 - mode 0x1D,0x1F: keyboard jump page
LD PG, $KSCANE_PG
#34
