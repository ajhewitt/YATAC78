# H-sync at end of process cycle on standard execute
INCLUDE ../inc/unary.nsa
INCLUDE ../inc/zpage.nsa
INCLUDE ../inc/pages.nsa
PAGE PSYNCE_PG

# PMODE: column in VID used during process cycle
# VLINE: line(page) in video ram
# VMS: [mode_line][e][cycle count]
#           0,1,2  0  0,1,2,3,4,5
#         3,4,5,6  1  0,1,2,3,4
#        7,8,9,10     0,1,2,3,4
#  11,12,13,14,15     0,1,2,3
# assumes Y=$VMS
LDZ HL, $INCPROC$NULL
FNH DZ, HLD               # H=mode_line start, L=E001
LD Y, $PMODE
VIDH DZ, SA               # mode_line, pmode —> S
#9/7
LDP HL, $IDEN$IDEN        # sign bit low, don’t inc vline
LDN HL, $INC$IDEN         # sign bit high, inc vline
LD Y, $VLINE
FNFH DZ, VD               # increment? vline —> V
FNFL E, HL                # H = serial inputs
#20/17
LD Y, $COMLS
COMH DZ, ND               # update comms line state
LD HL, $IDEN$8
LD Y, $COMPS
#29/25
FNFH AZ, ND               # comms line state -> comms process state
DIVL E, HL                # H = ps2 clk
LD Y, $COMLS
MVH DZ, ND                # H -> ps2 state
#40/33
LD HL, $SWAP$NULL
LDZ Y, $IMASK
FNH DZ, HLA               # A = IMASK<<4
LDP HL, $0xFF             # IMODE: -1
LDN HL, $0                # IMODE: 0
#49/42
LD Y, $IMODE
MVHL AZ, ND               # HL -> IMODE
LD HL, $INC$NULL
LDZ Y, $PLINE
#59/50
FNH DZ, HLD               # A,pline = pline+1
LD HL, $IDEN$NULL
LDZ Y, $VMODE
FNH DZ, HL                # H = vmode
LD Y, $PMODE
#69/58
VIDH AZ, ND               # VID(vmode,pline) -> pmode
LD HL, $IDEN$NULL
LDP PC, $NEXT_FIELD       # jump if pmode zero?
NOP
LDZ Y, $INST
FNH DZ, HL                # inst cache -> HL
#80/68
LD Y, $VMS                # set Y = $VMS on exit
VMPHL DZ, PGA             # jump to next VMC
#86/72

$NEXT_FIELD
LD Y, $PLINE
MULH DZ, ND               # 0 -> pline
#81/76
LDZ Y, $VMODE
FNH DZ, HL                # H = vmode
LD Y, $PMODE
VIDH AZ, ND               # VID(vmode,pline) -> pmode
#90/83
LD HL, $IDEN$NULL
LD Y, $VSTART
FNFH DZ, NA               # A = vertical start
LDZ Y, $VLINE
FNH AZ, HLD               # vstart -> vline
#101/92
LD HL, $INC$NULL
LDZ Y, $FRAME
FNFH DZ, ND               # frame count +1
LDP PC, $KBD_SCAN              # scan keyboard on FRAME 0
NOP
#110/101
NOP
NOP
NOP
LDZ Y, $VMS
FNH DZ, HLD               # VMS +1
LD HL, $IDEN$NULL
LDZ Y, $INST
#121/111
FNH DZ, HL                # inst cache -> HL
LD Y, $VMS                # set Y = $VMS on exit
VMPHL DZ, PGA             # jump to next VMC
#129/117

$KBD_SCAN
#110/117
LD HL, $0x18
LD Y, $EREG
ORHL DZ, ED               # E | 00011000 -> E
LD HL, $INC$NULL
#120/125
LDZ Y, $CMODE             # -1(off)->0(kbd,off), 1(serial)->2(kbd,serial)
FNH DZ, HLD               # kbd scan -> CMODE
NOP
NOP                       # LD HL, $FETCH
NOP
NOP                       # LD Y, $INST
NOP
NOP
#130
NOP
NOP                       # MVHL AZ, ND
LD HL, $INC2$RTCPG
LD Y, $VMS
FNFH DZ, ND               # VMS +2
#139
FNEL A, PG                # fork to RTC page
#142
